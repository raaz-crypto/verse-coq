(** Tactics for proof goal presentation *)
Require Import Verse.AnnotatedCode.
Require Import Verse.BitVector.
Require Import Verse.BitVector.ArithRing.
Require Import Verse.Machine.BitVector.
Require Import Verse.ModularCode.
Require Import Verse.Monoid.
Require Import Verse.Utils.hlist.

Require Import List.
Import List.ListNotations.

(* Destruct the variable store for easier access to valuations *)

Fixpoint hlamn [T] (A : T -> Type) (sc : list T)
  : (hlist A sc -> Type) -> Type
  := match sc as sc0
           return (hlist _ sc0 -> Type) -> Type
     with
     | []  => fun f => f []%hlist
     | n => fun f => forall a, hlamn _ _ (fun x => f (a::x)%hlist)
     end.

Lemma forallhlist [T] (A : T -> Type) sc f
  : hlamn A sc f
    ->
    forall x : hlist A sc, f x.
  induction sc.
  apply casenil.

  intros.
  pose (IHsc _ (X (hlist.hd x)) (hlist.tl x)).
  rewrite hlist_eta.
  exact f0.
Qed.

Ltac breakStore :=
  let st := fresh "st" in
  match goal with
  | |- forall _, _ => intro st; simpl in st; revert st
  end;
  (match goal with
   | |- forall _ : _ ?f ?l, _  => refine (forallhlist f l _ _)
     (* This refine is very fragile. Break at the drop of a hat.
        `apply`, for eg, doesn't work here!
        Maybe find a more robust solution instead
      *)
   end;
   unfold hlamn; intros).

Ltac unwrap := match goal with
               | |- ?I => try unfold I
               end; autounfold with Wrapper; simpl.

(* TODO : While the following two tactics are fairly generic, they
          don't work without specific BitVector functions. Needs to be
          organized better.
 *)

Ltac simplify := unfold getProp;
                 breakStore;
                 lazy -[
                   BVplus BVminus BVmul BVquot
                          BVrotR BVrotL BVshiftL BVshiftR BVcomp
                          zero one
                   (*
                            fromNibbles
                              numBinOp numUnaryOp numBigargExop numOverflowBinop
                              Nat.add Nat.sub Nat.mul Nat.div Nat.pow
                              N.add N.sub N.mul N.div N.div_eucl N.modulo

                              Ox nth replace
                    *)
                 ] in *;
                 repeat
                   (match goal with
                    | |- True            => constructor
                    | |- ?x = ?x         => trivial
                    | |- _ /\ _          => constructor
                    | |- _ -> _          => intro
                    | _                  => now trivial
                    | H : _ /\ _ |- _    => destruct H
                    | H : True |- _      => clear H
                    | H : True |- _           => clear H
                    | H : Datatypes.unit |- _ => clear H
                    end).
                   (*                 | |- forall _, _ => intro*)
(* The next should only ever be invoked
                           for a Prop generated by `tpt` *)
(*                 | |- ?I          => unfold I;
                                     autounfold with Wrapper *)(*unfold I;
                                            unfold tpt;
                                            unfold cp*)
                   (*                        | |- getProp _ _ => first [ modProof | unfold getProp ]*)
(* The next simply takes care of a functional
                           application. Should only be used once for
                           `tpt`
 *)
(*| |- context f [ ?F _ ] => unfold F*)

Ltac realize := unwrap; simplify.

Ltac modProof :=
  let rec inner := try match goal with
                     | |- context [getProp _ (linesDenote (inline_calls ?l))]
                       => rewrite (splitEq l); apply modularize;
                          unfold modularProof; simpl;
                          repeat match goal with
                            | |- distinctAll _ /\ _ =>  constructor;
                                                        [> unfold distinctAll; simpl; easy
                                                        | breakStore ]
                            end
                     end
  in inner.

Ltac mrealize := unwrap; modProof;
                 try simplify.
